// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Bond.Comm.Epoxy;

// suppress "This async methods lacks 'await' operators"
// The abstract class methods Bond generates for you are async.
// In this example, we only have synchronous code.
#pragma warning disable CS1998

// This is the same namespace declared in calculator.bond.
namespace Bond.Comm.Examples.Calculator
{
    // CalculatorServiceBase is generated by Bond from this definition:
    //
    // service Calculator
    // {
    //     Result Add(BinaryOpArgs);
    //     Result Divide(BinaryOpArgs);
    // }
    // 
    // The base class has an abstract method for each method in the service definition. You can extend it and implement
    // those methods to create a complete service.
    class CalculatorService : CalculatorServiceBase
    {
        // Add two numbers.
        public override async Task<IMessage<Result>> AddAsync(IMessage<BinaryOpArgs> param, CancellationToken ct)
        {
            // The arguments are passed as a parameterized IMessage, which is a BinaryOpsArgs in serialized form. This
            // allows you to avoid performing deserialization if you can know whether you want to handle a request
            // without looking at it.
            var args = param.Payload.Deserialize();

            var sum = args.left + args.right;
            var result = new Result
            {
                value = sum
            };

            return Message.FromPayload(result);
        }

        // Divide two numbers. Unlike Add, this call can return an error (if the divisor is zero).
        public override async Task<IMessage<Result>> DivideAsync(IMessage<BinaryOpArgs> param, CancellationToken ct)
        {
            var args = param.Payload.Deserialize();

            if (args.right == 0)
            {
                var error = new Error
                {
                    error_code = (int) CalculatorErrorCode.DivideByZero,
                    message = "Cannot divide by zero!"
                };
                return Message.FromError<Result>(error);
            }

            var quotient = args.left / args.right;
            var result = new Result
            {
                value = quotient
            };

            return Message.FromPayload(result);
        }

        public static void Main()
        {
            // Provide a sink so you can get Bond's log messages and forward them to your favorite logging system.
            // There is a similar interface for per-connection and per-request metrics.
            Log.SetHandler(new ConsoleLogger());

            // Bond has an abstraction for network protocols called a Transport. Epoxy is a custom protocol that is
            // lightweight and built into Bond.Comm. If it doesn't meet your needs, you can write your own Transports.
            var transport = new EpoxyTransportBuilder().Construct();
            var listener = transport.MakeListener(new IPEndPoint(IPAddress.Loopback, EpoxyTransport.DefaultPort));
            listener.AddService(new CalculatorService());

            // When this Task completes, your service will be up and accepting requests.
            listener.StartAsync().Wait();

            // Block and let the service run.
            Console.WriteLine($"{nameof(CalculatorService)} up and running. Press enter to exit.");
            Console.ReadLine();
        }

        // Implements a sink for Bond's log messages. Write one to connect Bond to whatever log framework you prefer.
        private class ConsoleLogger : LogHandler
        {
            public void Handle(LogSeverity severity, Exception exception, string format, object[] args)
            {
                if (severity > LogSeverity.Debug)
                {
                    Console.WriteLine($"{severity}: " + string.Format(format, args));
                }
            }
        }
    }
}
